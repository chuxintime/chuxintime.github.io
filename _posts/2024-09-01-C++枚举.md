---
layout:     post
title:      C++枚举
subtitle:   作用域枚举和非作用域枚举
date:       2024-05-07
author:     BY
header-img: img/post-bg-cook.jpg
catalog: true
tags:
    - C++




---

## C++非作用域枚举和作用域枚举的区别

区别主要包括：定义方式、作用域、类型安全和使用方法。

### 1. 定义方式

**非作用域枚举（C++98/03）：**

使用传统的`enum`关键字定义。枚举类型直接暴露在其声明的作用域中。

```C++
enum Color{
    Red,
    Green,
    Blue
};
```

**作用域枚举（C++11及以后）：**

使用`enum class` 或者`enum struct`关键字定义。枚举值在枚举类型的作用域内。

```
enum class Color{
	Red,
	Green,
	Blue
}
```

### 2. 作用域

**非作用域枚举：**

- 枚举值被导入到外部作用域中，可以直接使用枚举值
- 缺点：可能会与其他枚举的枚举值冲突，列如如果有另一个枚举（如`Shape`）也有`Red`值，那么就会有冲突。

**作用域枚举：**

- 枚举值在其定义的枚举类型的作用域内，需要使用 `EnumName::EnumValue` 形式访问枚举值。
- 优点：避免枚举值的名字冲突，确保更好的类型安全性。

### 1.3 类型安全性

**非作用域枚举：**

非作用域枚举的枚举值是隐式转换为整数的，这可能导致类型不安全的代码。

```c++
enum Color { Red, Green, Blue };
int value = Red;  // 隐式转换为整数 0（枚举值的底层类型是 int）
```

**作用域枚举：**

作用域枚举不会隐式转换为整数类型。要进行转换，必须显式使用 `static_cast` 或 `std::underlying_type`。

```c++
enum class Color { Red, Green, Blue };
// int value = Color::Red;  // 错误：不能隐式转换为整数
int value = static_cast<int>(Color::Red);  // 正确：需要显式转换
```

### 1.4 底层类型的指定

**非作用域枚举：**

枚举的底层类型通常是`int`，并且枚举的每个值都会被分配一个整型值（默认从 `0` 开始递增）。但在C++ 11之前不能直接指定。C++ 11之后可以使用`:<type>`指定底层类型。

```c++
enum Color : unsigned int { Red, Green, Blue };  // C++11 中可以这样做
```

**作用域枚举：**

作用域枚举可以在定义时明确指定其底层类型，这样可以节省内存或控制数据的存储方式。

```C++
enum class Color : char {Red, Creen, Blue}; //枚举的底层类型是char
```

### 1.5 默认输出

**非作用域枚举：**

非作用域枚举可以直接用整数表示，且可以用 `std::cout` 输出。

**作用域枚举：**

作用域枚举不能直接输出，需要进行类型转换后才能输出。

### 1.6 总结

| 特性                   | 非作用域枚举               | 作用域枚举                     |
| ---------------------- | -------------------------- | ------------------------------ |
| 定义方式               | `enum`                     | `enum class` 或 `enum struct`  |
| 作用域                 | 外部作用域                 | 枚举类型的内部作用域           |
| 类型安全性             | 不是类型安全的             | 类型安全的                     |
| 是否支持隐式转换为整数 | 是                         | 否                             |
| 底层类型的指定         | 默认 `int`，C++11 可以指定 | 必须明确指定底层类型           |
| 枚举值的访问方式       | 直接使用枚举值             | 需要使用 `EnumName::EnumValue` |

作用域枚举是C++11 引入的一项改进，提供了更好的类型安全和更明确的作用域控制，在现代 C++ 编程中被广泛使用。